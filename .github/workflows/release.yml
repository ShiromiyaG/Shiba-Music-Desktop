name: Build and Release

on:
  push:
    branches:
      - main
      - master
    paths:
      - 'version.txt'
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (leave empty to use version.txt)'
        required: false
        type: string
      force_release:
        description: 'Force build even if the tag already exists'
        required: false
        type: boolean
        default: false

env:
  QT_VERSION: '6.9.3'
  DISCORD_CLIENT_ID: ${{ secrets.DISCORD_CLIENT_ID }}

jobs:
  create-release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
    outputs:
      version: ${{ steps.version.outputs.version }}
      tag: ${{ steps.version.outputs.tag }}
      tag_exists: ${{ steps.check_tag.outputs.exists }}
      should_build: ${{ steps.check_tag.outputs.continue }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
    
    - name: Read version
      id: version
      env:
        INPUT_VERSION: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.version || '' }}
      run: |
        if [ -n "$INPUT_VERSION" ]; then
          VERSION="$INPUT_VERSION"
          echo "Using version from manual input: $VERSION"
        else
          VERSION=$(tr -d '\n' < version.txt | tr -d '\r')
          echo "Using version from version.txt: $VERSION"
        fi

        if [ -z "$VERSION" ]; then
          echo "‚ùå Version could not be determined" >&2
          exit 1
        fi

        echo "version=$VERSION" >> $GITHUB_OUTPUT
        echo "tag=v$VERSION" >> $GITHUB_OUTPUT
        echo "üì¶ Version: $VERSION"
    
    - name: Check if tag exists
      id: check_tag
      env:
        VERSION: ${{ steps.version.outputs.version }}
        FORCE_RELEASE: ${{ github.event_name == 'workflow_dispatch' && github.event.inputs.force_release || 'false' }}
      run: |
        TAG="v$VERSION"
        if git rev-parse "$TAG" >/dev/null 2>&1; then
          echo "exists=true" >> $GITHUB_OUTPUT
          if [ "$FORCE_RELEASE" = "true" ]; then
            echo "continue=true" >> $GITHUB_OUTPUT
            echo "üîÅ Tag $TAG already exists but force_release enabled"
          else
            echo "continue=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è  Tag $TAG already exists"
          fi
        else
          echo "exists=false" >> $GITHUB_OUTPUT
          echo "continue=true" >> $GITHUB_OUTPUT
          echo "‚úÖ Tag $TAG is new"
        fi
    
    - name: Create and push tag
      if: steps.check_tag.outputs.exists == 'false'
      env:
        RELEASE_TOKEN: ${{ secrets.RELEASE_TOKEN }}
      run: |
        git config user.name "github-actions[bot]"
        git config user.email "github-actions[bot]@users.noreply.github.com"
        git tag -a "${{ steps.version.outputs.tag }}" -m "Release version ${{ steps.version.outputs.version }}"
        git push https://x-access-token:${RELEASE_TOKEN}@github.com/${{ github.repository }}.git "${{ steps.version.outputs.tag }}"
        echo "üè∑Ô∏è  Tag ${{ steps.version.outputs.tag }} created and pushed"

  build-windows:
    needs: create-release
    if: needs.create-release.outputs.should_build == 'true'
    runs-on: windows-latest
    permissions:
      contents: write
      packages: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive
        ref: ${{ needs.create-release.outputs.tag }}
    
    - name: Install Qt
      uses: jurplel/install-qt-action@v4
      with:
        version: ${{ env.QT_VERSION }}
        host: 'windows'
        target: 'desktop'
        arch: 'win64_mingw'
        modules: 'qtmultimedia qt5compat qtshadertools'
        tools: 'tools_mingw1310'
    
    - name: Setup Ninja
      uses: seanmiddleditch/gha-setup-ninja@master
    
    - name: Download and setup libmpv
      run: |
        Write-Host "Downloading libmpv..."
        
        # Use GitHub Releases mirror (more reliable than SourceForge)
        $mpvUrl = "https://github.com/shinchiro/mpv-winbuild-cmake/releases/download/20251031/mpv-dev-x86_64-20251031-git-454d9eb.7z"
        $mpvArchive = "mpv-dev.7z"
        
        # Download with retry
        $maxAttempts = 3
        $attempt = 0
        $downloaded = $false
        
        while (-not $downloaded -and $attempt -lt $maxAttempts) {
            $attempt++
            try {
                Write-Host "Download attempt $attempt of $maxAttempts..."
                Invoke-WebRequest -Uri $mpvUrl -OutFile $mpvArchive -MaximumRetryCount 3
                $downloaded = $true
                Write-Host "‚úÖ Download successful"
            } catch {
                Write-Host "‚ö†Ô∏è  Attempt $attempt failed: $_"
                if ($attempt -eq $maxAttempts) {
                    throw "Failed to download libmpv after $maxAttempts attempts"
                }
                Start-Sleep -Seconds 5
            }
        }
        
        # Extract using 7zip
        Write-Host "Extracting libmpv..."
        7z x $mpvArchive -o"mpv-temp" -y
        
        # Create libs structure
        Write-Host "Setting up directory structure..."
        New-Item -ItemType Directory -Force -Path "libs/mpv/include" | Out-Null
        New-Item -ItemType Directory -Force -Path "libs/mpv/lib" | Out-Null
        New-Item -ItemType Directory -Force -Path "libs/mpv/bin" | Out-Null
        
        # Copy files to correct structure
        Write-Host "Copying files..."
        Copy-Item -Recurse -Force "mpv-temp/include/*" "libs/mpv/include/"
        Copy-Item -Force "mpv-temp/*.a" "libs/mpv/lib/" -ErrorAction SilentlyContinue
        Copy-Item -Force "mpv-temp/*.dll.a" "libs/mpv/lib/" -ErrorAction SilentlyContinue
        Copy-Item -Force "mpv-temp/*.dll" "libs/mpv/bin/" -ErrorAction SilentlyContinue
        
        # Cleanup
        Write-Host "Cleaning up..."
        Remove-Item $mpvArchive -Force
        Remove-Item -Recurse -Force mpv-temp
        
        # Verify
        Write-Host "`n‚úÖ libmpv setup complete!"
        Write-Host "Include dir exists: $(Test-Path 'libs/mpv/include/mpv/client.h')"
        if (Test-Path 'libs/mpv/lib') {
            Write-Host "Lib files: $(Get-ChildItem 'libs/mpv/lib' -Name | Out-String)"
        }
        if (Test-Path 'libs/mpv/bin') {
            Write-Host "Bin files: $(Get-ChildItem 'libs/mpv/bin' -Name | Out-String)"
        }
    
    - name: Configure CMake
      run: |
        $env:PATH = "$env:IQTA_TOOLS\mingw1310_64\bin;$env:PATH"
        $env:DISCORD_CLIENT_ID = "${{ secrets.DISCORD_CLIENT_ID }}"
        cmake -B build -G Ninja -DCMAKE_BUILD_TYPE=Release -DCMAKE_C_COMPILER=gcc -DCMAKE_CXX_COMPILER=g++
    
    - name: Build
      run: |
        $env:PATH = "$env:IQTA_TOOLS\mingw1310_64\bin;$env:PATH"
        $env:DISCORD_CLIENT_ID = "${{ secrets.DISCORD_CLIENT_ID }}"
        cmake --build build --config Release
    
    - name: Deploy bundle
      run: |
        $ErrorActionPreference = "Stop"
        $deployDir = Join-Path (Resolve-Path build) "deploy"
        if (Test-Path $deployDir) {
          Remove-Item $deployDir -Recurse -Force
        }
        New-Item -ItemType Directory -Path $deployDir | Out-Null

        Copy-Item "build\shibamusic.exe" -Destination $deployDir -Force

        $buildRoot = Resolve-Path build
        $updaterCandidates = @(
          Join-Path $buildRoot "updater\updater.exe",
          Join-Path $buildRoot "updater\Release\updater.exe",
          Join-Path $buildRoot "Release\updater.exe",
          Join-Path $buildRoot "updater.exe"
        )

        $updaterExe = $updaterCandidates | Where-Object { Test-Path $_ } | Select-Object -First 1
        if ($null -ne $updaterExe) {
          Copy-Item $updaterExe -Destination $deployDir -Force
        } else {
          throw "Updater executable not found. Checked paths:`n  - $($updaterCandidates -join ([Environment]::NewLine + '  - '))"
        }

        $mpvDll = "libs\mpv\bin\libmpv-2.dll"
        if (-not (Test-Path $mpvDll)) {
          throw "libmpv-2.dll not found at $mpvDll"
        }
        Copy-Item $mpvDll -Destination $deployDir -Force

        $qtRoot = $env:QT_ROOT_DIR
        $qtBin = Join-Path $qtRoot "bin"
        $windeployqt = Join-Path $qtBin "windeployqt.exe"
        if (-not (Test-Path $windeployqt)) {
          throw "windeployqt not found at $windeployqt"
        }

        $shaderToolsCandidate = Join-Path $qtRoot "lib\Qt6ShaderTools.dll"
        if (Test-Path $shaderToolsCandidate) {
          $shaderToolsDest = Join-Path $qtBin "Qt6ShaderTools.dll"
          if (-not (Test-Path $shaderToolsDest)) {
            Copy-Item $shaderToolsCandidate -Destination $shaderToolsDest -Force
          }
        }

        $env:PATH = "$qtBin;$(Join-Path $env:IQTA_TOOLS 'mingw1310_64\bin');$env:PATH"
        & $windeployqt --release --no-translations --compiler-runtime --qmldir qml --qmldir qml/components --qmldir qml/pages "$deployDir\shibamusic.exe"

        if (-not (Test-Path (Join-Path $deployDir 'Qt6Core.dll'))) {
          throw "Qt DLLs were not deployed correctly"
        }

        $opensslDirs = @(
          (Join-Path $qtRoot 'bin'),
          (Join-Path $qtRoot 'lib'),
          (Join-Path $env:IQTA_TOOLS 'OpenSSL\Win_x64\bin')
        ) | Where-Object { $_ -and (Test-Path $_) }

        foreach ($lib in @('libssl-3-x64.dll','libcrypto-3-x64.dll')) {
          if (-not (Test-Path (Join-Path $deployDir $lib))) {
            foreach ($dir in $opensslDirs) {
              $candidate = Join-Path $dir $lib
              if (Test-Path $candidate) {
                Copy-Item $candidate -Destination $deployDir -Force
                break
              }
            }
          }
        }

        $platformDll = Join-Path $deployDir 'platforms\qwindows.dll'
        if (-not (Test-Path $platformDll)) {
          throw "Qt platform plugin not found at $platformDll"
        }

        foreach ($dll in @('libgcc_s_seh-1.dll','libstdc++-6.dll','libwinpthread-1.dll')) {
          $mingwDll = Join-Path $env:IQTA_TOOLS "mingw1310_64\bin\$dll"
          if (Test-Path $mingwDll) {
            Copy-Item $mingwDll -Destination $deployDir -Force
          }
        }

        Write-Host "Deployment directory:" 
        Get-ChildItem $deployDir | ForEach-Object { Write-Host "  - $($_.Name)" }
    
    - name: Create archive
      run: |
        Compress-Archive -Path "build\deploy\*" -DestinationPath "ShibaMusic-Windows-x64.zip"
    
    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: ShibaMusic-Windows
        path: ShibaMusic-Windows-x64.zip
    
    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        tag_name: ${{ needs.create-release.outputs.tag }}
        name: Release ${{ needs.create-release.outputs.version }}
        body: |
          ## Shiba Music ${{ needs.create-release.outputs.version }}
          
          ### üì¶ Downloads
          
          - **Windows (x64)**: ShibaMusic-Windows-x64.zip
          
          ### üìù Installation
          
          1. Download the ZIP file
          2. Extract to a folder
          3. Run `shibamusic.exe`
          
          ### ‚ú® What's New
          
          See [CHANGELOG.md](https://github.com/${{ github.repository }}/blob/main/CHANGELOG.md) for details.
          
          ---
          
          **Full Changelog**: https://github.com/${{ github.repository }}/compare/v${{ needs.create-release.outputs.version }}...HEAD
        files: ShibaMusic-Windows-x64.zip
        draft: false
        prerelease: false
      env:
        GITHUB_TOKEN: ${{ secrets.RELEASE_TOKEN }}
